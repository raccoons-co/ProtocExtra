/*
 * Copyright 2024, Raccoons. Developing simple way to change.
 *
 * @license MIT
 */

package co.raccoons.protoc.plugin.core;

import com.google.common.annotations.VisibleForTesting;
import com.google.errorprone.annotations.Immutable;
import com.google.protobuf.Descriptors.Descriptor;
import com.google.protobuf.Descriptors.FileDescriptor;

import java.util.Arrays;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Strings.isNullOrEmpty;
import static java.lang.String.format;

/**
 * Name that are generated by the Java protoc plugin.
 *
 * @see <a href="https://protobuf.dev/reference/java/java-proto-names/">...</a>
 */
interface JavaProtoName {

    String JAVA_FILE_NAME_PATTERN = "%s/%s.java";

    FileDescriptor file();

    ProtocolTypeSet types();

    default String messageFileName(Descriptor messageType) {
        return format(JAVA_FILE_NAME_PATTERN, directory(), message(messageType));
    }

    default String orBuilderFileName(Descriptor messageType) {
        return format(JAVA_FILE_NAME_PATTERN, directory(), orBuilder(messageType));
    }

    default String outerClassFileName() {
        return format(JAVA_FILE_NAME_PATTERN, directory(), outerClass());
    }

    private String message(Descriptor messageType) {
        return isJavaMultipleFiles()
                ? messageMultiple(messageType)
                : outerClass();
    }

    private String messageMultiple(Descriptor messageType) {
        return isTopLevel(messageType)
                ? messageType.getName()
                : topLevelName(messageType.getContainingType());
    }

    private String orBuilder(Descriptor messageType) {
        return isJavaMultipleFiles()
                ? orBuilderMultiple(messageType)
                : outerClass();
    }

    private String orBuilderMultiple(Descriptor messageType) {
        return isTopLevel(messageType)
                ? messageType.getName() + "OrBuilder"
                : topLevelName(messageType.getContainingType());
    }

    private String outerClass() {
        var outerClass = file().getOptions().getJavaOuterClassname();
        return isNullOrEmpty(outerClass)
                ? derivedOuterClass()
                : outerClass;
    }

    private String derivedOuterClass() {
        var protoFileName = file().getName();
        var derivedOuterClass = SimpleName.fromProtoName(protoFileName);
        return types().contains(derivedOuterClass)
                ? appendPostfix(derivedOuterClass)
                : derivedOuterClass;
    }

    private String appendPostfix(String className) {
        return className + "OuterClass";
    }

    private String directory() {
        return javaPackage().replaceAll("\\.", "/");
    }

    private boolean isJavaMultipleFiles() {
        return file().getOptions().getJavaMultipleFiles();
    }

    private String javaPackage() {
        var javaPackage = file().getOptions().getJavaPackage();
        return isNullOrEmpty(javaPackage)
                ? protoPackage()
                : javaPackage;
    }

    private String protoPackage() {
        var protoPackage = file().getPackage();
        checkArgument(!isNullOrEmpty(protoPackage), "Package name is undefined");
        return protoPackage;
    }

    private String topLevelName(Descriptor messageType) {
        return isTopLevel(messageType)
                ? messageType.getName()
                : topLevelName(messageType.getContainingType());
    }

    private boolean isTopLevel(Descriptor messageType) {
        return messageType.getContainingType() == null;
    }

    @Immutable
    final class SimpleName {

        private static final String PROTO_REGEX = "\\.proto$";
        private static final String EMPTY_PATTERN = "";

        private SimpleName() {
        }

        @VisibleForTesting
        public static String fromProtoName(String filename) {
            checkArgument(!isNullOrEmpty(filename));
            var simpleName = filename.replaceAll(PROTO_REGEX, EMPTY_PATTERN);
            return snakeToPascalCase(simpleName);
        }

        private static String snakeToPascalCase(String snake) {
            return Arrays.stream(snake.split("_"))
                    .filter(Predicate.not(String::isEmpty))
                    .map(SimpleName::capitalize)
                    .collect(Collectors.joining());
        }

        private static String capitalize(String value) {
            return value.substring(0, 1).toUpperCase() + value.substring(1);
        }
    }
}
